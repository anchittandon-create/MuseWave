/**
 * Python Engine Bridge
 * Spawns Python processes for Riffusion, Magenta, and Coqui TTS
 */

import { execa } from 'execa';
import path from 'path';
import fs from 'fs-extra';
import { env } from '../env.js';

export interface PythonEngineResult {
  success: boolean;
  outputPath?: string;
  error?: string;
  stdout?: string;
  stderr?: string;
  duration?: number;
}

/**
 * Generate music using Riffusion (text-to-audio diffusion)
 */
export async function generateRiffusion(
  prompt: string,
  outputPath: string,
  options: {
    duration?: number;
    seed?: number;
    numInferenceSteps?: number;
  } = {}
): Promise<PythonEngineResult> {
  const startTime = Date.now();
  
  try {
    console.log(`üéµ Riffusion: Generating audio for prompt: "${prompt}"`);
    
    // Ensure output directory exists
    await fs.ensureDir(path.dirname(outputPath));
    
    // Build Riffusion command
    const args = [
      '-m', 'riffusion.cli',
      '--prompt', prompt,
      '--output', outputPath,
      '--duration', String(options.duration || 30),
    ];
    
    if (options.seed) {
      args.push('--seed', String(options.seed));
    }
    
    if (options.numInferenceSteps) {
      args.push('--num_inference_steps', String(options.numInferenceSteps));
    }
    
    // Execute Python command
    const result = await execa(env.PYTHON_BIN, args, {
      timeout: env.GENERATION_TIMEOUT_MS,
      env: {
        ...process.env,
        PYTHONPATH: env.RIFFUSION_PATH || process.env.PYTHONPATH,
      },
    });
    
    // Verify output file exists
    const exists = await fs.pathExists(outputPath);
    if (!exists) {
      throw new Error('Riffusion output file was not created');
    }
    
    const duration = Date.now() - startTime;
    console.log(`‚úÖ Riffusion completed in ${(duration / 1000).toFixed(2)}s`);
    
    return {
      success: true,
      outputPath,
      stdout: result.stdout,
      stderr: result.stderr,
      duration,
    };
  } catch (error: any) {
    console.error('‚ùå Riffusion error:', error.message);
    return {
      success: false,
      error: error.message,
      stdout: error.stdout,
      stderr: error.stderr,
      duration: Date.now() - startTime,
    };
  }
}

/**
 * Generate MIDI melody using Magenta
 */
export async function generateMagentaMelody(
  outputDir: string,
  options: {
    duration?: number;
    temperature?: number;
    numOutputs?: number;
  } = {}
): Promise<PythonEngineResult> {
  const startTime = Date.now();
  
  try {
    console.log(`üéπ Magenta: Generating MIDI melody`);
    
    // Ensure output directory exists
    await fs.ensureDir(outputDir);
    
    // Build Magenta command
    const args = [
      '-m', 'magenta.scripts.melody_rnn_generate',
      '--num_outputs', String(options.numOutputs || 1),
      '--num_steps', String(Math.floor((options.duration || 30) * 4)), // Rough step estimation
      '--output_dir', outputDir,
      '--primer_melody', '[60]', // Middle C primer
    ];
    
    if (options.temperature) {
      args.push('--temperature', String(options.temperature));
    }
    
    // Execute Python command
    const result = await execa(env.PYTHON_BIN, args, {
      timeout: env.GENERATION_TIMEOUT_MS,
      env: {
        ...process.env,
        PYTHONPATH: env.MAGENTA_PATH || process.env.PYTHONPATH,
      },
    });
    
    // Find generated MIDI file
    const files = await fs.readdir(outputDir);
    const midiFile = files.find(f => f.endsWith('.mid') || f.endsWith('.midi'));
    
    if (!midiFile) {
      throw new Error('No MIDI file generated by Magenta');
    }
    
    const outputPath = path.join(outputDir, midiFile);
    const duration = Date.now() - startTime;
    console.log(`‚úÖ Magenta completed in ${(duration / 1000).toFixed(2)}s`);
    
    return {
      success: true,
      outputPath,
      stdout: result.stdout,
      stderr: result.stderr,
      duration,
    };
  } catch (error: any) {
    console.error('‚ùå Magenta error:', error.message);
    return {
      success: false,
      error: error.message,
      stdout: error.stdout,
      stderr: error.stderr,
      duration: Date.now() - startTime,
    };
  }
}

/**
 * Render MIDI to WAV using FluidSynth
 */
export async function renderMidiWithFluidSynth(
  midiPath: string,
  outputPath: string,
  soundFontPath?: string
): Promise<PythonEngineResult> {
  const startTime = Date.now();
  
  try {
    console.log(`üéº FluidSynth: Rendering MIDI to WAV`);
    
    // Ensure output directory exists
    await fs.ensureDir(path.dirname(outputPath));
    
    const sfPath = soundFontPath || env.SOUND_FONT_PATH;
    
    // Verify SoundFont exists
    const sfExists = await fs.pathExists(sfPath);
    if (!sfExists) {
      throw new Error(`SoundFont not found at ${sfPath}`);
    }
    
    // Build FluidSynth command
    const args = [
      '-ni', // No interactive mode
      sfPath,
      midiPath,
      '-F', outputPath,
      '-r', String(env.DEFAULT_SAMPLE_RATE),
    ];
    
    // Execute FluidSynth
    const result = await execa(env.FLUIDSYNTH_PATH, args, {
      timeout: env.GENERATION_TIMEOUT_MS,
    });
    
    // Verify output file exists
    const exists = await fs.pathExists(outputPath);
    if (!exists) {
      throw new Error('FluidSynth output file was not created');
    }
    
    const duration = Date.now() - startTime;
    console.log(`‚úÖ FluidSynth completed in ${(duration / 1000).toFixed(2)}s`);
    
    return {
      success: true,
      outputPath,
      stdout: result.stdout,
      stderr: result.stderr,
      duration,
    };
  } catch (error: any) {
    console.error('‚ùå FluidSynth error:', error.message);
    return {
      success: false,
      error: error.message,
      stdout: error.stdout,
      stderr: error.stderr,
      duration: Date.now() - startTime,
    };
  }
}

/**
 * Generate vocals using Coqui TTS
 */
export async function generateCoquiVocals(
  text: string,
  outputPath: string,
  options: {
    language?: string;
    speaker?: string;
    emotion?: string;
  } = {}
): Promise<PythonEngineResult> {
  const startTime = Date.now();
  
  try {
    console.log(`üé§ Coqui TTS: Generating vocals`);
    
    // Ensure output directory exists
    await fs.ensureDir(path.dirname(outputPath));
    
    // Build Coqui TTS command
    const args = [
      '--text', text,
      '--out_path', outputPath,
    ];
    
    if (options.language) {
      args.push('--language', options.language.toLowerCase());
    }
    
    if (options.speaker) {
      args.push('--speaker', options.speaker);
    }
    
    // Execute TTS command
    const result = await execa('tts', args, {
      timeout: env.GENERATION_TIMEOUT_MS,
      env: {
        ...process.env,
        PYTHONPATH: env.COQUI_TTS_PATH || process.env.PYTHONPATH,
      },
    });
    
    // Verify output file exists
    const exists = await fs.pathExists(outputPath);
    if (!exists) {
      throw new Error('Coqui TTS output file was not created');
    }
    
    const duration = Date.now() - startTime;
    console.log(`‚úÖ Coqui TTS completed in ${(duration / 1000).toFixed(2)}s`);
    
    return {
      success: true,
      outputPath,
      stdout: result.stdout,
      stderr: result.stderr,
      duration,
    };
  } catch (error: any) {
    console.error('‚ùå Coqui TTS error:', error.message);
    return {
      success: false,
      error: error.message,
      stdout: error.stdout,
      stderr: error.stderr,
      duration: Date.now() - startTime,
    };
  }
}

/**
 * Verify Python dependencies are installed
 */
export async function verifyPythonDependencies(): Promise<{
  riffusion: boolean;
  magenta: boolean;
  coqui: boolean;
  fluidsynth: boolean;
}> {
  const results = {
    riffusion: false,
    magenta: false,
    coqui: false,
    fluidsynth: false,
  };
  
  // Check Riffusion
  try {
    await execa(env.PYTHON_BIN, ['-c', 'import riffusion'], { timeout: 5000 });
    results.riffusion = true;
  } catch {}
  
  // Check Magenta
  try {
    await execa(env.PYTHON_BIN, ['-c', 'import magenta'], { timeout: 5000 });
    results.magenta = true;
  } catch {}
  
  // Check Coqui TTS
  try {
    await execa('tts', ['--help'], { timeout: 5000 });
    results.coqui = true;
  } catch {}
  
  // Check FluidSynth
  try {
    await execa(env.FLUIDSYNTH_PATH, ['--version'], { timeout: 5000 });
    results.fluidsynth = true;
  } catch {}
  
  return results;
}
